const {
    app,
    BrowserWindow,
    ipcMain,
    Menu,
    Tray,
    globalShortcut,
    clipboard,
    screen,
    shell,
    nativeImage
} = require('electron');
const path = require('path');
const { execSync } = require('child_process');
const ConfigStore = require('./config-store');
const axios = require('axios');

// 全局变量
let mainWindow;
let tray;
let floatingWindow;
let configStore;
let clipboardWatcher;
let lastClipboard = '';
let detectorWindow = null; // 用于智能划词检测

// 应用初始化
app.whenReady().then(() => {
    // 初始化配置存储
    configStore = new ConfigStore();

    // 创建窗口与托盘
    createMainWindow();
    createFloatingWindow();
    createTray();

    // 注册IPC处理器
    registerIPCHandlers();

    // 根据配置启动功能
    const config = configStore.get('general');

    // 根据触发方式启动相应功能
    const triggerMode = (config && config.triggerMode) || 'shortcut'; // shortcut, clipboard, smart

    if (triggerMode === 'clipboard' && config.enableClipboardWatch) {
        startClipboardWatcher();
    } else if (triggerMode === 'smart') {
        startSmartSelectionDetector();
    } else {
        // 默认使用快捷键方式
        registerGlobalShortcut((config && config.shortcut) || 'CommandOrControl+Q');
    }

    app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) {
            createMainWindow();
        }
    });
});

// 创建主窗口（设置页面）
function createMainWindow() {
    mainWindow = new BrowserWindow({
        width: 900,
        height: 700,
        show: false,
        webPreferences: {
            contextIsolation: true,
            preload: path.join(__dirname, 'preload-settings.js')
        },
        icon: path.join(__dirname, 'assets', 'icon.png')
    });

    mainWindow.loadFile('settings.html');

    mainWindow.on('close', (e) => {
        // 仅在非退出时拦截关闭，避免阻止应用退出
        if (!app.isQuiting) {
            e.preventDefault();
            mainWindow.hide();
        }
    });
}

// 创建悬浮窗口
function createFloatingWindow() {
    floatingWindow = new BrowserWindow({
        width: 400,
        height: 70,
        frame: false,
        transparent: true,
        alwaysOnTop: true,
        skipTaskbar: true,
        resizable: false,
        show: false,
        webPreferences: {
            contextIsolation: true,
            preload: path.join(__dirname, 'preload-floating.js')
        }
    });

    floatingWindow.loadFile('floating.html');

    floatingWindow.on('close', (e) => {
        if (!app.isQuiting) {
            e.preventDefault();
            floatingWindow.hide();
        }
    });

    // 失去焦点时隐藏
    floatingWindow.on('blur', () => {
        setTimeout(() => {
            if (floatingWindow && !floatingWindow.isDestroyed()) {
                floatingWindow.hide();
            }
        }, 200);
    });
}

// 创建系统托盘
function createTray() {
    const iconPath = path.join(__dirname, 'assets', 'tray-icon.png');

    // 如果图标不存在，创建一个简单的图标
    let trayIcon;
    try {
        trayIcon = nativeImage.createFromPath(iconPath);
    } catch (e) {
        // 创建一个占位图标
        trayIcon = nativeImage.createEmpty();
    }

    tray = new Tray(trayIcon);

    const contextMenu = Menu.buildFromTemplate([
        {
            label: '设置',
            click: () => {
                mainWindow.show();
                mainWindow.focus();
            }
        },
        {
            label: '触发方式',
            submenu: [
                {
                    label: '快捷键触发',
                    type: 'radio',
                    checked: configStore.get('general.triggerMode') === 'shortcut' || !configStore.get('general.triggerMode'),
                    click: () => {
                        configStore.set('general.triggerMode', 'shortcut');
                        app.relaunch();
                        app.exit();
                    }
                },
                {
                    label: '智能划词（直接触发）',
                    type: 'radio',
                    checked: configStore.get('general.triggerMode') === 'smart',
                    click: () => {
                        configStore.set('general.triggerMode', 'smart');
                        app.relaunch();
                        app.exit();
                    }
                },
                {
                    label: '剪贴板监听',
                    type: 'radio',
                    checked: configStore.get('general.triggerMode') === 'clipboard',
                    click: () => {
                        configStore.set('general.triggerMode', 'clipboard');
                        configStore.set('general.enableClipboardWatch', true);
                        app.relaunch();
                        app.exit();
                    }
                }
            ]
        },
        { type: 'separator' },
        {
            label: '重新加载',
            click: () => {
                app.relaunch();
                app.exit();
            }
        },
        {
            label: '退出',
            click: () => {
                app.isQuiting = true;
                app.quit();
            }
        }
    ]);

    tray.setToolTip('AI划词助手');
    tray.setContextMenu(contextMenu);
}

// 注册IPC处理器
function registerIPCHandlers() {
    // 配置相关
    ipcMain.handle('get-config', () => {
        return configStore.data;
    });

    ipcMain.handle('set-config', (event, key, value) => {
        return configStore.set(key, value);
    });

    ipcMain.handle('get-buttons', () => {
        return configStore.getButtons();
    });

    ipcMain.handle('add-button', (event, button) => {
        return configStore.addButton(button);
    });

    ipcMain.handle('update-button', (event, id, updates) => {
        return configStore.updateButton(id, updates);
    });

    ipcMain.handle('delete-button', (event, id) => {
        return configStore.deleteButton(id);
    });

    // AI功能处理
    ipcMain.handle('perform-ai-action', async (event, data) => {
        try {
            const result = await callAIAPI(data);

            // 显示结果窗口
            showResultWindow(data.buttonName || data.action, data.text, result);

            // 隐藏悬浮窗口
            if (floatingWindow) {
                floatingWindow.hide();
            }

            return { success: true, result };
        } catch (error) {
            console.error('AI API调用失败:', error);
            return { success: false, error: error.message };
        }
    });

    // 测试API连接
    ipcMain.handle('test-api', async () => {
        try {
            const result = await callAIAPI({
                text: 'Hello',
                prompt: '请回复"API连接正常"'
            });
            return { success: true, result };
        } catch (error) {
            return { success: false, error: error.message };
        }
    });

    // 打开外部链接
    ipcMain.handle('open-external', (event, url) => {
        shell.openExternal(url);
    });
}

// 调用AI API
async function callAIAPI(data) {
    const apiConfig = configStore.get('api');
    const provider = apiConfig.provider;

    switch (provider) {
        case 'openai':
            return await callOpenAI(data, apiConfig.openai);
        case 'azure':
            return await callAzureOpenAI(data, apiConfig.azure);
        case 'custom':
            return await callCustomAPI(data, apiConfig.custom);
        case 'dify':
            return await callDifyAPI(data, apiConfig.dify);
        default:
            throw new Error('未配置API提供商');
    }
}

// 调用OpenAI API
async function callOpenAI(data, config) {
    if (!config.apiKey) {
        throw new Error('请先配置OpenAI API Key');
    }

    const response = await axios.post(
        `${config.apiUrl}/chat/completions`,
        {
            model: config.model,
            messages: [
                {
                    role: 'user',
                    content: data.prompt || data.text
                }
            ],
            temperature: config.temperature,
            max_tokens: config.maxTokens
        },
        {
            headers: {
                'Authorization': `Bearer ${config.apiKey}`,
                'Content-Type': 'application/json'
            }
        }
    );

    return response.data.choices[0].message.content;
}

// 调用Azure OpenAI API
async function callAzureOpenAI(data, config) {
    if (!config.apiKey || !config.endpoint || !config.deploymentName) {
        throw new Error('请先配置Azure OpenAI参数');
    }

    const response = await axios.post(
        `${config.endpoint}/openai/deployments/${config.deploymentName}/chat/completions?api-version=${config.apiVersion || '2023-05-15'}`,
        {
            messages: [
                {
                    role: 'user',
                    content: data.prompt || data.text
                }
            ]
        },
        {
            headers: {
                'api-key': config.apiKey,
                'Content-Type': 'application/json'
            }
        }
    );

    return response.data.choices[0].message.content;
}

// 调用自定义API（支持SSE流式）
async function callCustomAPI(data, config) {
    if (!config.url) {
        throw new Error('请先配置自定义API地址');
    }

    // 替换模板中的占位符
    let body = config.bodyTemplate || '{}';
    body = body.replace('{text}', data.text);
    body = body.replace('{prompt}', data.prompt || data.text);
    body = body.replace('{query}', data.text);

    // 解析body为对象以便修改
    let bodyObj = JSON.parse(body);

    // 如果是dify API，设置必要的参数
    if (config.url.includes('chat-messages')) {
        bodyObj = {
            inputs: {},
            query: data.text,
            response_mode: 'streaming',
            conversation_id: '',
            user: 'user-' + Date.now(),
            files: []
        };
    }

    // 检查是否是流式API
    const isStreaming = bodyObj.response_mode === 'streaming' || config.streaming;

    if (isStreaming) {
        // 流式处理
        return new Promise((resolve, reject) => {
            const https = require('https');
            const http = require('http');
            const url = require('url');

            const parsedUrl = url.parse(config.url);
            const protocol = parsedUrl.protocol === 'https:' ? https : http;

            const options = {
                hostname: parsedUrl.hostname,
                port: parsedUrl.port,
                path: parsedUrl.path,
                method: config.method || 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...config.headers,
                    'Accept': 'text/event-stream'
                }
            };

            let fullResponse = '';

            const req = protocol.request(options, (res) => {
                res.setEncoding('utf8');

                res.on('data', (chunk) => {
                    // 解析SSE数据
                    const lines = chunk.split('\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const d = JSON.parse(line.slice(6));
                                if (d.event === 'message' && d.answer) {
                                    fullResponse += d.answer;
                                    if (global.currentResultWindow && !global.currentResultWindow.isDestroyed()) {
                                        global.currentResultWindow.webContents.send('update-result', {
                                            text: fullResponse,
                                            incremental: d.answer,
                                            streaming: true
                                        });
                                    }
                                } else if (d.event === 'message_end') {
                                    resolve(fullResponse);
                                }
                            } catch (e) {
                                // 忽略解析错误
                            }
                        }
                    }
                });

                res.on('end', () => {
                    resolve(fullResponse);
                });
            });

            req.on('error', (e) => {
                reject(e);
            });

            req.write(JSON.stringify(bodyObj));
            req.end();
        });
    } else {
        // 非流式处理（原有逻辑）
        const response = await axios({
            method: config.method || 'POST',
            url: config.url,
            headers: config.headers || {},
            data: bodyObj
        });

        // 尝试从响应中提取结果
        if (typeof response.data === 'string') {
            return response.data;
        } else if (response.data.result) {
            return response.data.result;
        } else if (response.data.data) {
            return response.data.data;
        } else if (response.data.choices && response.data.choices[0]) {
            return response.data.choices[0].message?.content || response.data.choices[0].text;
        }

        return JSON.stringify(response.data);
    }
}

// 调用 Dify API（强制流式）
async function callDifyAPI(data, config) {
    if (!config.apiKey) {
        throw new Error('请先配置 Dify API Key');
    }

    const headers = {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json',
        'Accept': 'text/event-stream'
    };

    const queryText = data.prompt || data.text;

    const bodyObj = {
        inputs: {},
        query: queryText,
        response_mode: 'streaming',
        conversation_id: '',
        user: 'user-' + Date.now(),
        files: []
    };

    return new Promise((resolve, reject) => {
        const https = require('https');
        const http = require('http');
        const url = require('url');

        const parsedUrl = url.parse(config.url);
        const protocol = parsedUrl.protocol === 'https:' ? https : http;

        const options = {
            hostname: parsedUrl.hostname,
            port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),
            path: parsedUrl.path,
            method: 'POST',
            headers
        };

        let fullResponse = '';
        let buffer = '';

        const req = protocol.request(options, (res) => {
            if (res.statusCode < 200 || res.statusCode >= 300) {
                let errorBody = '';
                res.on('data', (chunk) => (errorBody += chunk));
                res.on('end', () => {
                    reject(new Error(`API请求失败 (${res.statusCode}): ${errorBody || res.statusMessage}`));
                });
                return;
            }

            res.setEncoding('utf8');

            res.on('data', (chunk) => {
                buffer += chunk;
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine) continue;
                    if (trimmedLine.startsWith('data: ')) {
                        const dataStr = trimmedLine.slice(6);
                        if (dataStr === '[DONE]') {
                            resolve(fullResponse || '处理完成');
                            return;
                        }
                        try {
                            const d = JSON.parse(dataStr);
                            if (d.event === 'message') {
                                if (d.answer !== undefined) {
                                    fullResponse += d.answer;
                                    if (global.currentResultWindow && !global.currentResultWindow.isDestroyed()) {
                                        global.currentResultWindow.webContents.send('update-result', {
                                            text: fullResponse,
                                            incremental: d.answer,
                                            streaming: true
                                        });
                                    }
                                }
                            } else if (d.event === 'message_end') {
                                resolve(fullResponse || '处理完成');
                                return;
                            }
                            if (!d.event && d.answer !== undefined) {
                                fullResponse += d.answer;
                                if (global.currentResultWindow && !global.currentResultWindow.isDestroyed()) {
                                    global.currentResultWindow.webContents.send('update-result', {
                                        text: fullResponse,
                                        incremental: d.answer,
                                        streaming: true
                                    });
                                }
                            }
                        } catch (e) {
                            // 忽略解析错误
                        }
                    }
                }
            });

            res.on('end', () => {
                if (!fullResponse) {
                    resolve('未收到有效响应');
                } else {
                    resolve(fullResponse);
                }
            });
        });

        req.on('error', (e) => {
            reject(new Error('网络请求失败: ' + e.message));
        });

        req.setTimeout(30000);
        req.on('timeout', () => {
            try { req.destroy(); } catch (e) {}
            reject(new Error('请求超时'));
        });

        req.write(JSON.stringify(bodyObj));
        req.end();
    });
}

// 显示结果窗口
function showResultWindow(action, text, result) {
    const resultWindow = new BrowserWindow({
        width: 600,
        height: 500,
        frame: true,
        alwaysOnTop: true,
        webPreferences: {
            contextIsolation: true,
            preload: path.join(__dirname, 'preload-result.js')
        },
        icon: path.join(__dirname, 'assets', 'icon.png')
    });

    // 保存当前结果窗口的引用，用于流式更新
    global.currentResultWindow = resultWindow;

    resultWindow.loadFile('result.html');

    resultWindow.webContents.on('did-finish-load', () => {
        resultWindow.webContents.send('show-result', {
            action,
            text,
            result
        });
    });

    resultWindow.on('closed', () => {
        global.currentResultWindow = null;
    });
}

// 显示悬浮窗口
function showFloatingWindow(position, text) {
    if (!floatingWindow || text.length > configStore.get('general.maxTextLength')) {
        return;
    }

    const display = screen.getDisplayNearestPoint(position);
    const { width, height } = display.workAreaSize;
    const windowBounds = floatingWindow.getBounds();

    let x = position.x - windowBounds.width / 2;
    let y = position.y + 20;

    // 边界检查
    if (x < display.bounds.x) x = display.bounds.x;
    if (x + windowBounds.width > display.bounds.x + width) {
        x = display.bounds.x + width - windowBounds.width;
    }
    if (y + windowBounds.height > display.bounds.y + height) {
        y = position.y - windowBounds.height - 20;
    }

    floatingWindow.setPosition(Math.round(x), Math.round(y));
    floatingWindow.webContents.send('show-text', text);
    floatingWindow.showInactive();
}

// 开始剪贴板监听
function startClipboardWatcher() {
    const interval = configStore.get('general.clipboardWatchInterval') || 500;

    clipboardWatcher = setInterval(() => {
        const currentClipboard = clipboard.readText();

        if (currentClipboard && currentClipboard !== lastClipboard && currentClipboard.trim().length > 0) {
            lastClipboard = currentClipboard;
            const mousePos = screen.getCursorScreenPoint();
            showFloatingWindow(mousePos, currentClipboard);
        }
    }, interval);
}

// 智能文本选择检测
let lastMouseUpTime = 0;
let lastSelectedText = '';
let mouseUpTimer = null;
let isDetecting = false;
let smartDetectorInterval = null;

function startSmartSelectionDetector() {
    console.log('启动智能划词检测...');

    // 通过隐形窗口持有前台权限（避免 Windows 上焦点问题）
    detectorWindow = new BrowserWindow({
        width: 1,
        height: 1,
        x: -100,
        y: -100,
        frame: false,
        transparent: true,
        alwaysOnTop: true,
        skipTaskbar: true,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false
        }
    });
    detectorWindow.setIgnoreMouseEvents(true);
    detectorWindow.hide();
    detectorWindow.on('closed', () => { detectorWindow = null; });

    // 使用定时器检测选中的文本
    smartDetectorInterval = setInterval(() => {
        if (isDetecting) return;

        const currentMousePos = screen.getCursorScreenPoint();

        // 保存当前剪贴板
        const oldClipboard = clipboard.readText();

        // 清空剪贴板
        clipboard.clear();

        // 模拟复制
        simulateCopyShortcut();

        // 检查剪贴板
        setTimeout(() => {
            const selectedText = clipboard.readText();

            // 恢复原剪贴板
            if (oldClipboard) {
                clipboard.writeText(oldClipboard);
            }

            // 如果有新的选中文本
            if (
                selectedText &&
                selectedText.trim().length > 0 &&
                selectedText !== lastSelectedText &&
                selectedText.trim().length <= configStore.get('general.maxTextLength')
            ) {
                lastSelectedText = selectedText;

                // 显示悬浮窗
                showFloatingWindow(currentMousePos, selectedText);

                // 防止连续触发
                isDetecting = true;
                setTimeout(() => {
                    isDetecting = false;
                }, 1000);
            }
        }, 120);
    }, 600); // 每600ms检查一次
}

function stopSmartSelectionDetector() {
    if (smartDetectorInterval) {
        clearInterval(smartDetectorInterval);
        smartDetectorInterval = null;
        console.log('停止智能划词检测');
    }
    if (detectorWindow && !detectorWindow.isDestroyed()) {
        try { detectorWindow.destroy(); } catch (e) {}
        detectorWindow = null;
    }
}

// 停止剪贴板监听
function stopClipboardWatcher() {
    if (clipboardWatcher) {
        clearInterval(clipboardWatcher);
        clipboardWatcher = null;
    }
}

// 注册全局快捷键
function registerGlobalShortcut(shortcut) {
    globalShortcut.unregisterAll();

    if (shortcut) {
        globalShortcut.register(shortcut, () => {
            // 保存当前剪贴板
            const oldClipboard = clipboard.readText();

            // 模拟复制
            simulateCopyShortcut();

            // 等待复制完成
            setTimeout(() => {
                const selectedText = clipboard.readText();

                if (selectedText && selectedText !== oldClipboard) {
                    const mousePos = screen.getCursorScreenPoint();
                    showFloatingWindow(mousePos, selectedText);

                    // 恢复剪贴板
                    setTimeout(() => {
                        clipboard.writeText(oldClipboard);
                    }, 100);
                }
            }, 80);
        });
    }
}

// 跨平台模拟 Ctrl/Cmd+C 复制
function simulateCopyShortcut() {
    try {
        if (process.platform === 'darwin') {
            execSync('osascript -e "tell application \"System Events\" to keystroke \"c\" using command down"');
        } else if (process.platform === 'win32') {
            // 使用 PowerShell 的 WScript.Shell 发送 Ctrl+C
            const ps = '"$ws=New-Object -ComObject WScript.Shell; $ws.SendKeys(\'^c\')"';
            execSync(`powershell -NoProfile -NonInteractive -Command ${ps}`);
        } else {
            // Linux: 尝试使用 xdotool，如果不可用则忽略
            try {
                execSync('xdotool key --clearmodifiers ctrl+c');
            } catch (e) {
                // 忽略
            }
        }
    } catch (e) {
        // 忽略任何失败，以免影响主流程
    }
}

// 防止多开
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
    app.quit();
} else {
    app.on('second-instance', () => {
        if (mainWindow) {
            if (mainWindow.isMinimized()) mainWindow.restore();
            mainWindow.show();
            mainWindow.focus();
        }
    });
}

// 应用退出前清理
app.on('before-quit', () => {
    // 标记正在退出，避免 close 事件里阻止窗口销毁
    app.isQuiting = true;
});

app.on('will-quit', () => {
    // 只在app ready之后才能使用globalShortcut
    if (app.isReady()) {
        globalShortcut.unregisterAll();
    }
    if (clipboardWatcher) {
        clearInterval(clipboardWatcher);
    }
    // 停止智能划词检测
    stopSmartSelectionDetector();
    // 主/悬浮窗口销毁，释放资源
    try { if (floatingWindow && !floatingWindow.isDestroyed()) floatingWindow.destroy(); } catch (e) {}
    try { if (mainWindow && !mainWindow.isDestroyed()) mainWindow.destroy(); } catch (e) {}
    // 销毁托盘
    try { if (tray) tray.destroy(); } catch (e) {}
});

app.on('window-all-closed', () => {
    // 不退出应用，保持在系统托盘
});

const {
    app,
    BrowserWindow,
    ipcMain,
    Menu,
    Tray,
    globalShortcut,
    clipboard,
    screen,
    shell,
    nativeImage
} = require('electron');
const path = require('path');
const { execSync } = require('child_process');
const ConfigStore = require('./config-store');
const axios = require('axios');

// 全局变量
let mainWindow;
let tray;
let floatingWindow;
let configStore;
let clipboardWatcher;
let lastClipboard = '';
let detectorWindow = null; // 用于智能划词检测

// 应用初始化
app.whenReady().then(() => {
    // 初始化配置存储
    configStore = new ConfigStore();

    // 创建窗口与托盘
    createMainWindow();
    createFloatingWindow();
    createTray();

    // 注册IPC处理器
    registerIPCHandlers();

    // 根据配置启动功能
    const config = configStore.get('general');

    // 根据触发方式启动相应功能
    const triggerMode = (config && config.triggerMode) || 'shortcut'; // shortcut, clipboard, smart

    if (triggerMode === 'clipboard' && config.enableClipboardWatch) {
        startClipboardWatcher();
    } else if (triggerMode === 'smart') {
        startSmartSelectionDetector();
    } else {
        // 默认使用快捷键方式
        registerGlobalShortcut((config && config.shortcut) || 'CommandOrControl+Q');
    }

    app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) {
            createMainWindow();
        }
    });
});

// 创建主窗口（设置页面）
function createMainWindow() {
    mainWindow = new BrowserWindow({
        width: 900,
        height: 700,
        show: false,
        webPreferences: {
            contextIsolation: true,
            preload: path.join(__dirname, 'preload-settings.js')
        },
        icon: path.join(__dirname, 'assets', 'icon.png')
    });

    mainWindow.loadFile('settings.html');

    mainWindow.on('close', (e) => {
        // 仅在非退出时拦截关闭，避免阻止应用退出
        if (!app.isQuiting) {
            e.preventDefault();
            mainWindow.hide();
        }
    });
}

// 创建悬浮窗口
function createFloatingWindow() {
    floatingWindow = new BrowserWindow({
        width: 400,
        height: 70,
        frame: false,
        transparent: true,
        alwaysOnTop: true,
        skipTaskbar: true,
        resizable: false,
        show: false,
        webPreferences: {
            contextIsolation: true,
            preload: path.join(__dirname, 'preload-floating.js')
        }
    });

    floatingWindow.loadFile('floating.html');

    floatingWindow.on('close', (e) => {
        if (!app.isQuiting) {
            e.preventDefault();
            floatingWindow.hide();
        }
    });

    // 失去焦点时隐藏
    floatingWindow.on('blur', () => {
        setTimeout(() => {
            if (floatingWindow && !floatingWindow.isDestroyed()) {
                floatingWindow.hide();
            }
        }, 200);
    });
}

// 创建系统托盘
function createTray() {
    const iconPath = path.join(__dirname, 'assets', 'tray-icon.png');

    // 如果图标不存在，创建一个简单的图标
    let trayIcon;
    try {
        trayIcon = nativeImage.createFromPath(iconPath);
    } catch (e) {
        // 创建一个占位图标
        trayIcon = nativeImage.createEmpty();
    }

    tray = new Tray(trayIcon);

    const contextMenu = Menu.buildFromTemplate([
        {
            label: '设置',
            click: () => {
                mainWindow.show();
                mainWindow.focus();
            }
        },
        {
            label: '触发方式',
            submenu: [
                {
                    label: '快捷键触发',
                    type: 'radio',
                    checked: configStore.get('general.triggerMode') === 'shortcut' || !configStore.get('general.triggerMode'),
                    click: () => {
                        configStore.set('general.triggerMode', 'shortcut');
                        app.relaunch();
                        app.exit();
                    }
                },
                {
                    label: '智能划词（直接触发）',
                    type: 'radio',
                    checked: configStore.get('general.triggerMode') === 'smart',
                    click: () => {
                        configStore.set('general.triggerMode', 'smart');
                        app.relaunch();
                        app.exit();
                    }
                },
                {
                    label: '剪贴板监听',
                    type: 'radio',
                    checked: configStore.get('general.triggerMode') === 'clipboard',
                    click: () => {
                        configStore.set('general.triggerMode', 'clipboard');
                        configStore.set('general.enableClipboardWatch', true);
                        app.relaunch();
                        app.exit();
                    }
                }
            ]
        },
        { type: 'separator' },
        {
            label: '重新加载',
            click: () => {
                app.relaunch();
                app.exit();
            }
        },
        {
            label: '退出',
            click: () => {
                app.isQuiting = true;
                app.quit();
            }
        }
    ]);

    tray.setToolTip('AI划词助手');
    tray.setContextMenu(contextMenu);
}

// 注册IPC处理器
function registerIPCHandlers() {
    // 配置相关
    ipcMain.handle('get-config', () => {
        return configStore.data;
    });

    ipcMain.handle('set-config', (event, key, value) => {
        return configStore.set(key, value);
    });

    ipcMain.handle('get-buttons', () => {
        return configStore.getButtons();
    });

    ipcMain.handle('add-button', (event, button) => {
        return configStore.addButton(button);
    });

    ipcMain.handle('update-button', (event, id, updates) => {
        return configStore.updateButton(id, updates);
    });

    ipcMain.handle('delete-button', (event, id) => {
        return configStore.deleteButton(id);
    });

    // AI功能处理
    ipcMain.handle('perform-ai-action', async (event, data) => {
        try {
            const result = await callAIAPI(data);

            // 显示结果窗口
            showResultWindow(data.buttonName || data.action, data.text, result);

            // 隐藏悬浮窗口
            if (floatingWindow) {
                floatingWindow.hide();
            }

            return { success: true, result };
        } catch (error) {
            console.error('AI API调用失败:', error);
            return { success: false, error: error.message };
        }
    });

    // 测试API连接
    ipcMain.handle('test-api', async () => {
        try {
            const result = await callAIAPI({
                text: 'Hello',
                prompt: '请回复"API连接正常"'
            });
            return { success: true, result };
        } catch (error) {
            return { success: false, error: error.message };
        }
    });

    // 打开外部链接
    ipcMain.handle('open-external', (event, url) => {
        shell.openExternal(url);
    });
}

// 调用AI API
async function callAIAPI(data) {
    const apiConfig = configStore.get('api');
    const provider = apiConfig.provider;

    switch (provider) {
        case 'openai':
            return await callOpenAI(data, apiConfig.openai);
        case 'azure':
            return await callAzureOpenAI(data, apiConfig.azure);
        case 'custom':
            return await callCustomAPI(data, apiConfig.custom);
        case 'dify':
            return await callDifyAPI(data, apiConfig.dify);
        default:
            throw new Error('未配置API提供商');
    }
}

// 调用OpenAI API
async function callOpenAI(data, config) {
    if (!config.apiKey) {
        throw new Error('请先配置OpenAI API Key');
    }

    const response = await axios.post(
        `${config.apiUrl}/chat/completions`,
        {
            model: config.model,
            messages: [
                {
                    role: 'user',
                    content: data.prompt || data.text
                }
            ],
            temperature: config.temperature,
            max_tokens: config.maxTokens
        },
        {
            headers: {
                'Authorization': `Bearer ${config.apiKey}`,
                'Content-Type': 'application/json'
            }
        }
    );

    return response.data.choices[0].message.content;
}

// 调用Azure OpenAI API
async function callAzureOpenAI(data, config) {
    if (!config.apiKey || !config.endpoint || !config.deploymentName) {
        throw new Error('请先配置Azure OpenAI参数');
    }

    const response = await axios.post(
        `${config.endpoint}/openai/deployments/${config.deploymentName}/chat/completions?api-version=${config.apiVersion || '2023-05-15'}`,
        {
            messages: [
                {
                    role: 'user',
                    content: data.prompt || data.text
                }
            ]
        },
        {
            headers: {
                'api-key': config.apiKey,
                'Content-Type': 'application/json'
            }
        }
    );

    return response.data.choices[0].message.content;
}

// 调用自定义API（支持SSE流式）
async function callCustomAPI(data, config) {
    if (!config.url) {
        throw new Error('请先配置自定义API地址');
    }

    // 替换模板中的占位符
    let body = config.bodyTemplate || '{}';
    body = body.replace('{text}', data.text);
    body = body.replace('{prompt}', data.prompt || data.text);
    body = body.replace('{query}', data.text);

    // 解析body为对象以便修改
    let bodyObj = JSON.parse(body);

    // 如果是dify API，设置必要的参数
    if (config.url.includes('chat-messages')) {
        bodyObj = {
            inputs: {},
            query: data.text,
            response_mode: 'streaming',
            conversation_id: '',
            user: 'user-' + Date.now(),
            files: []
        };
    }

    // 检查是否是流式API
    const isStreaming = bodyObj.response_mode === 'streaming' || config.streaming;

    if (isStreaming) {
        // 流式处理
        return new Promise((resolve, reject) => {
            const https = require('https');
            const http = require('http');
            const url = require('url');

            const parsedUrl = url.parse(config.url);
            const protocol = parsedUrl.protocol === 'https:' ? https : http;

            const options = {
                hostname: parsedUrl.hostname,
                port: parsedUrl.port,
                path: parsedUrl.path,
                method: config.method || 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...config.headers,
                    'Accept': 'text/event-stream'
                }
            };

            let fullResponse = '';

            const req = protocol.request(options, (res) => {
                res.setEncoding('utf8');

                res.on('data', (chunk) => {
                    // 解析SSE数据
                    const lines = chunk.split('\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const d = JSON.parse(line.slice(6));
                                if (d.event === 'message' && d.answer) {
                                    fullResponse += d.answer;
                                    if (global.currentResultWindow && !global.currentResultWindow.isDestroyed()) {
                                        global.currentResultWindow.webContents.send('update-result', {
                                            text: fullResponse,
                                            incremental: d.answer,
                                            streaming: true
                                        });
                                    }
                                } else if (d.event === 'message_end') {
                                    resolve(fullResponse);
                                }
                            } catch (e) {
                                // 忽略解析错误
                            }
                        }
                    }
                });

                res.on('end', () => {
                    resolve(fullResponse);
                });
            });

            req.on('error', (e) => {
                reject(e);
            });

            req.write(JSON.stringify(bodyObj));
            req.end();
        });
    } else {
        // 非流式处理（原有逻辑）
        const response = await axios({
            method: config.method || 'POST',
            url: config.url,
            headers: config.headers || {},
            data: bodyObj
        });

        // 尝试从响应中提取结果
        if (typeof response.data === 'string') {
            return response.data;
        } else if (response.data.result) {
            return response.data.result;
        } else if (response.data.data) {
            return response.data.data;
        } else if (response.data.choices && response.data.choices[0]) {
            return response.data.choices[0].message?.content || response.data.choices[0].text;
        }

        return JSON.stringify(response.data);
    }
}

// 调用 Dify API（强制流式）
async function callDifyAPI(data, config) {
    if (!config.apiKey) {
        throw new Error('请先配置 Dify API Key');
    }

    const headers = {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json',
        'Accept': 'text/event-stream'
    };

    const queryText = data.prompt || data.text;

    const bodyObj = {
        inputs: {},
        query: queryText,
        response_mode: 'streaming',
        conversation_id: '',
        user: 'user-' + Date.now(),
        files: []
    };

    return new Promise((resolve, reject) => {
        const https = require('https');
        const http = require('http');
        const url = require('url');

        const parsedUrl = url.parse(config.url);
        const protocol = parsedUrl.protocol === 'https:' ? https : http;

        const options = {
            hostname: parsedUrl.hostname,
            port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),
            path: parsedUrl.path,
            method: 'POST',
            headers
        };

        let fullResponse = '';
        let buffer = '';

        const req = protocol.request(options, (res) => {
            if (res.statusCode < 200 || res.statusCode >= 300) {
                let errorBody = '';
                res.on('data', (chunk) => (errorBody += chunk));
                res.on('end', () => {
                    reject(new Error(`API请求失败 (${res.statusCode}): ${errorBody || res.statusMessage}`));
                });
                return;
            }

            res.setEncoding('utf8');

            res.on('data', (chunk) => {
                buffer += chunk;
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine) continue;
                    if (trimmedLine.startsWith('data: ')) {
                        const dataStr = trimmedLine.slice(6);
                        if (dataStr === '[DONE]') {
                            resolve(fullResponse || '处理完成');
                            return;
                        }
                        try {
                            const d = JSON.parse(dataStr);
                            if (d.event === 'message') {
                                if (d.answer !== undefined) {
                                    fullResponse += d.answer;
                                    if (global.currentResultWindow && !global.currentResultWindow.isDestroyed()) {
                                        global.currentResultWindow.webContents.send('update-result', {
                                            text: fullResponse,
                                            incremental: d.answer,
                                            streaming: true
                                        });
                                    }
                                }
                            } else if (d.event === 'message_end') {
                                resolve(fullResponse || '处理完成');
                                return;
                            }
                            if (!d.event && d.answer !== undefined) {
                                fullResponse += d.answer;
                                if (global.currentResultWindow && !global.currentResultWindow.isDestroyed()) {
                                    global.currentResultWindow.webContents.send('update-result', {
                                        text: fullResponse,
                                        incremental: d.answer,
                                        streaming: true
                                    });
                                }
                            }
                        } catch (e) {
                            // 忽略解析错误
                        }
                    }
                }
            });

            res.on('end', () => {
                if (!fullResponse) {
                    resolve('未收到有效响应');
                } else {
                    resolve(fullResponse);
                }
            });
        });

        req.on('error', (e) => {
            reject(new Error('网络请求失败: ' + e.message));
        });

        req.setTimeout(30000);
        req.on('timeout', () => {
            try { req.destroy(); } catch (e) {}
            reject(new Error('请求超时'));
        });

        req.write(JSON.stringify(bodyObj));
        req.end();
    });
}

// 显示结果窗口
function showResultWindow(action, text, result) {
    const resultWindow = new BrowserWindow({
        width: 600,
        height: 500,
        frame: true,
        alwaysOnTop: true,
        webPreferences: {
            contextIsolation: true,
            preload: path.join(__dirname, 'preload-result.js')
        },
        icon: path.join(__dirname, 'assets', 'icon.png')
    });

    // 保存当前结果窗口的引用，用于流式更新
    global.currentResultWindow = resultWindow;

    resultWindow.loadFile('result.html');

    resultWindow.webContents.on('did-finish-load', () => {
        resultWindow.webContents.send('show-result', {
            action,
            text,
            result
        });
    });

    resultWindow.on('closed', () => {
        global.currentResultWindow = null;
    });
}

// 显示悬浮窗口
function showFloatingWindow(position, text) {
    if (!floatingWindow || text.length > configStore.get('general.maxTextLength')) {
        return;
    }

    const display = screen.getDisplayNearestPoint(position);
    const { width, height } = display.workAreaSize;
    const windowBounds = floatingWindow.getBounds();

    let x = position.x - windowBounds.width / 2;
    let y = position.y + 20;

    // 边界检查
    if (x < display.bounds.x) x = display.bounds.x;
    if (x + windowBounds.width > display.bounds.x + width) {
        x = display.bounds.x + width - windowBounds.width;
    }
    if (y + windowBounds.height > display.bounds.y + height) {
        y = position.y - windowBounds.height - 20;
    }

    floatingWindow.setPosition(Math.round(x), Math.round(y));
    floatingWindow.webContents.send('show-text', text);
    floatingWindow.showInactive();
}

// 开始剪贴板监听
function startClipboardWatcher() {
    const interval = configStore.get('general.clipboardWatchInterval') || 500;

    clipboardWatcher = setInterval(() => {
        const currentClipboard = clipboard.readText();

        if (currentClipboard && currentClipboard !== lastClipboard && currentClipboard.trim().length > 0) {
            lastClipboard = currentClipboard;
            const mousePos = screen.getCursorScreenPoint();
            showFloatingWindow(mousePos, currentClipboard);
        }
    }, interval);
}

// 智能文本选择检测
let lastMouseUpTime = 0;
let lastSelectedText = '';
let mouseUpTimer = null;
let isDetecting = false;
let smartDetectorInterval = null;

function startSmartSelectionDetector() {
    console.log('启动智能划词检测...');

    // 通过隐形窗口持有前台权限（避免 Windows 上焦点问题）
    detectorWindow = new BrowserWindow({
        width: 1,
        height: 1,
        x: -100,
        y: -100,
        frame: false,
        transparent: true,
        alwaysOnTop: true,
        skipTaskbar: true,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false
        }
    });
    detectorWindow.setIgnoreMouseEvents(true);
    detectorWindow.hide();
    detectorWindow.on('closed', () => { detectorWindow = null; });

    // 使用定时器检测选中的文本
    smartDetectorInterval = setInterval(() => {
        if (isDetecting) return;

        const currentMousePos = screen.getCursorScreenPoint();

        // 保存当前剪贴板
        const oldClipboard = clipboard.readText();

        // 清空剪贴板
        clipboard.clear();

        // 模拟复制
        simulateCopyShortcut();

        // 检查剪贴板
        setTimeout(() => {
            const selectedText = clipboard.readText();

            // 恢复原剪贴板
            if (oldClipboard) {
                clipboard.writeText(oldClipboard);
            }

            // 如果有新的选中文本
            if (
                selectedText &&
                selectedText.trim().length > 0 &&
                selectedText !== lastSelectedText &&
                selectedText.trim().length <= configStore.get('general.maxTextLength')
            ) {
                lastSelectedText = selectedText;

                // 显示悬浮窗
                showFloatingWindow(currentMousePos, selectedText);

                // 防止连续触发
                isDetecting = true;
                setTimeout(() => {
                    isDetecting = false;
                }, 1000);
            }
        }, 100);
    }, 500); // 每500ms检查一次
}

function stopSmartSelectionDetector() {
    if (smartDetectorInterval) {
        clearInterval(smartDetectorInterval);
        smartDetectorInterval = null;
        console.log('停止智能划词检测');
    }
    if (detectorWindow && !detectorWindow.isDestroyed()) {
        try { detectorWindow.destroy(); } catch (e) {}
        detectorWindow = null;
    }
}

// 停止剪贴板监听
function stopClipboardWatcher() {
    if (clipboardWatcher) {
        clearInterval(clipboardWatcher);
        clipboardWatcher = null;
    }
}

// 注册全局快捷键
function registerGlobalShortcut(shortcut) {
    globalShortcut.unregisterAll();

    if (shortcut) {
        globalShortcut.register(shortcut, () => {
            // 保存当前剪贴板
            const oldClipboard = clipboard.readText();

            // 模拟复制
            simulateCopyShortcut();

            // 等待复制完成
            setTimeout(() => {
                const selectedText = clipboard.readText();

                if (selectedText && selectedText !== oldClipboard) {
                    const mousePos = screen.getCursorScreenPoint();
                    showFloatingWindow(mousePos, selectedText);

                    // 恢复剪贴板
                    setTimeout(() => {
                        clipboard.writeText(oldClipboard);
                    }, 100);
                }
            }, 80);
        });
    }
}

// 跨平台模拟 Ctrl/Cmd+C 复制
function simulateCopyShortcut() {
    try {
        if (process.platform === 'darwin') {
            execSync('osascript -e "tell application \"System Events\" to keystroke \"c\" using command down"');
        } else if (process.platform === 'win32') {
            // 使用 PowerShell 的 WScript.Shell 发送 Ctrl+C
            const ps = '"$ws=New-Object -ComObject WScript.Shell; $ws.SendKeys(\'^c\')"';
            execSync(`powershell -NoProfile -NonInteractive -Command ${ps}`);
        } else {
            // Linux: 尝试使用 xdotool，如果不可用则忽略
            try {
                execSync('xdotool key --clearmodifiers ctrl+c');
            } catch (e) {
                // 忽略
            }
        }
    } catch (e) {
        // 忽略任何失败，以免影响主流程
    }
}

// 防止多开
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
    app.quit();
} else {
    app.on('second-instance', () => {
        if (mainWindow) {
            if (mainWindow.isMinimized()) mainWindow.restore();
            mainWindow.show();
            mainWindow.focus();
        }
    });
}

// 应用退出前清理
app.on('before-quit', () => {
    // 标记正在退出，避免 close 事件里阻止窗口销毁
    app.isQuiting = true;
});

app.on('will-quit', () => {
    // 只在app ready之后才能使用globalShortcut
    if (app.isReady()) {
        globalShortcut.unregisterAll();
    }
    if (clipboardWatcher) {
        clearInterval(clipboardWatcher);
    }
    // 停止智能划词检测
    stopSmartSelectionDetector();
    // 主/悬浮窗口销毁，释放资源
    try { if (floatingWindow && !floatingWindow.isDestroyed()) floatingWindow.destroy(); } catch (e) {}
    try { if (mainWindow && !mainWindow.isDestroyed()) mainWindow.destroy(); } catch (e) {}
    // 销毁托盘
    try { if (tray) tray.destroy(); } catch (e) {}
});

app.on('window-all-closed', () => {
    // 不退出应用，保持在系统托盘
});

